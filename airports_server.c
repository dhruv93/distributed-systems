/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include "airports.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define pi 3.14159265358979323846
typedef struct kdnode kdtree;

struct kdnode
{
  char name[64];
  char code[3];
  double coords[3];
  kdtree *left;
  kdtree *right;
};

void ClosestFive(kdtree *cur, kdtree list[], double coords[], int axis);
void quickSort(kdtree list[], int, int, int);
int partition(kdtree list[], int, int, int);
kdtree *head;

airport_list * airports_1_svc(struct position *argp, struct svc_req *rqstp){
  static airport_list container;
  xdr_free((xdrproc_t)xdr_airport_list, (char *)&container);
  container.errno=0;
  airportlist* result = &container.airport_list_u.list;

  kdtree list[5];
  double coords[2];
  coords[0]=argp->latitude;
  coords[1]=argp->longitude;
  int x=0;
  for(x=0; x<5; x++){
	list[x].coords[0]=0;
	list[x].coords[1]=0;
	list[x].coords[2]=10000;
	list[x].name[0]='a';
	list[x].code[0]='a';
  }
  ClosestFive(head, list, coords, 1);

  int i=0;
  airportlist t;
  for(i=0; i<5; i++){
	t=(airportstruct *)malloc(sizeof(struct airportstruct));
	t->distance=list[i].coords[2];
	t->name=strdup(list[i].name);
	t->code=strdup(list[i].code);
	t->next=NULL;
	*result=t;
	result=&t->next;
  }
  return &container;
}

//Creates the entire tree given a list of kdnodes. Returns head
kdtree* CreateTree(kdtree list[], int left, int right, int axis){
  if(left>right){
	return NULL;
  }
  kdtree *node= malloc(sizeof(struct kdnode));
  quickSort(list, left, right, axis);

  int median = left+((right-left)/2);
  strcpy(node->name,list[median].name);
  strcpy(node->code,list[median].code);
  node->coords[0]= list[median].coords[0];
  node->coords[1]= list[median].coords[1];
  if(left<right){
	node->left = CreateTree(list, left, median-1, (axis+1)%2);
	node->right = CreateTree(list, median+1, right, (axis+1)%2);
  }
  return node;
}

//Recursive quicksort of the list parameter.
void quickSort(kdtree list[], int left, int right, int axis)
{
  int p;
  if( left < right ){
	p = partition(list, left, right, axis);
	quickSort(list, left, p-1, axis);
	quickSort(list, p+1, right, axis);
  }
}

int partition(kdtree list[], int left, int right, int axis) {
  int i, j;
  kdtree t;
  double pivot = list[left].coords[axis];
  i = left; j = right+1;
  while(1){
	do ++i;
	while( list[i].coords[axis] <= pivot && i <= right );
	do --j;
	while( list[j].coords[axis] > pivot );
	if( i >= j )
	  break;
	t = list[i];
	list[i] = list[j];
	list[j] = t;
  }
  t = list[left];
  list[left] = list[j];
  list[j] = t;
  return j;
}

//Distance calculation between two places on earth.
double deg2rad(double deg);
double rad2deg(double rad);

double distance(double lat1, double lon1, double lat2, double lon2, char unit){
  double theta, dist;
  theta = lon1 - lon2;
  dist = sin(deg2rad(lat1)) * sin(deg2rad(lat2)) + cos(deg2rad(lat1)) *
	cos(deg2rad(lat2)) * cos(deg2rad(theta));
  dist = acos(dist);
  dist = rad2deg(dist);
  dist = dist * 60 * 1.1515;
  switch(unit) {
  case 'M':
	break;
  case 'K':
	dist = dist * 1.609344;
	break;
  case 'N':
	dist = dist * 0.8684;
	break;
  }
  return (dist);
}

double deg2rad(double deg) {
  return (deg * pi / 180);
}

double rad2deg(double rad) {
  return (rad * 180 / pi);
}

//Search for five closest nodes.
void copyNode(kdtree *h, kdtree n[]){
  strcpy(n[4].name, h->name);
  strcpy(n[4].code, h->code);
  n[4].coords[0]=h->coords[0];
  n[4].coords[1]=h->coords[1];
  n[4].left=h->left;
  n[4].right=h->right;
}

void ClosestFive(kdtree *cur, kdtree list[], double coords[], int axis){
  if(cur!=NULL){
	if(cur->coords[axis]>coords[axis]){
	  ClosestFive(cur->left, list, coords, (axis+1)%2);
	  if(list[4].coords[0]==0&&list[4].coords[1]==0){
		copyNode(cur, list);
		list[4].coords[2]=distance(coords[0], coords[1],
								   cur->coords[0], cur->coords[1],'M');
		quickSort(list, 0, 4, 2);
	  }else if(distance(coords[0], coords[1],
						cur->coords[0], cur->coords[1],'M')<
			   distance(coords[0], coords[1],
						list[4].coords[0], list[4].coords[1],'M')){
		copyNode(cur, list);
		list[4].coords[2]=distance(coords[0], coords[1],
								   cur->coords[0], cur->coords[1],'M');
		quickSort(list, 0, 4, 2);
	  }
	  double lat1=coords[0];
	  double lon1=coords[1];
	  double lat2=cur->coords[0];
	  double lon2=cur->coords[1];
	  if(axis==1){
		lat2=lat1;
	  }else{
		lon2=lon1;
	  }
	  if(list[4].coords[0]==0&&list[4].coords[1]==0||
		 distance(lat1,lon1,lat2,lon2,'M')<
		 distance(list[4].coords[0],list[4].coords[1],
				  coords[0],coords[1],'M'))
		ClosestFive(cur->right, list, coords, (axis+1)%2);
	}else{
	  ClosestFive(cur->right, list, coords, (axis+1)%2);
	  if(list[4].coords[0]==0&&list[4].coords[1]==0){
		copyNode(cur, list);
		list[4].coords[2]=distance(coords[0], coords[1],
								   cur->coords[0], cur->coords[1],'M');
		quickSort(list, 0, 4, 2);
	  }else if(distance(coords[0], coords[1],
						cur->coords[0], cur->coords[1],'M')<
			   distance(coords[0], coords[1],
						list[4].coords[0], list[4].coords[1],'M')){
		copyNode(cur, list);
		list[4].coords[2]=distance(coords[0], coords[1],
								   cur->coords[0], cur->coords[1],'M');
		quickSort(list, 0, 4, 2);
	  }
	  double lat1=coords[0];
	  double lon1=coords[1];
	  double lat2=cur->coords[0];
	  double lon2=cur->coords[1];
	  if(axis==1){
		lat2=lat1;
	  }else{
		lon2=lon1;
	  }
	  if(list[4].coords[0]==0&&list[4].coords[1]==0||
		 distance(lat1,lon1,lat2,lon2,'M')<
		 distance(list[4].coords[0],list[4].coords[1],
				  coords[0],coords[1],'M'))
		ClosestFive(cur->left, list, coords, (axis+1)%2);
	}
  }
}

void main2( ){
  FILE *file = fopen("airport-locations.txt", "r");
  if(file==NULL){
	printf("File not found!\n");
	return;
  }

  kdtree sample[1200];
  char str[255], *lat, *lon, *cpy;
  int i=0;

  while(fgets(str, 255, file)!=NULL){
	if(str[0]=='[' && str[1]!='a'){
	  sample[i].code[0]=str[1];
	  sample[i].code[1]=str[2];
	  sample[i].code[2]=str[3];
	  lat=strchr(str, ' ');
	  sample[i].coords[0]=strtod(lat+1,&lon);
	  sample[i].coords[1]=strtod(lon,&cpy);
	  strcpy(str, cpy);
	  int x=0, y=0;
	  while((str[x]=='\t' || str[x]==' ') && str[x]!='\0'){
		x++;
	  }
	  while(str[x]!='\n' && str[x]!='\0'){
		sample[i].name[y]=str[x];
		x++;
		y++;
	  }
	  i++;
	}
  }
  head = CreateTree(sample, 0, i-1, 1);
}
