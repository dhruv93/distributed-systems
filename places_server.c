/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "places.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "airports.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//      TRIE DATA STRUCTURE                                                     //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
typedef struct trieNode {
  char key;
  char *entry;
  double longitude;
  double latitude;

  struct trieNode *parent;
  struct trieNode *children;
  struct trieNode *next;
  struct trieNode *previous;
}trieNode_t;

void trieCreate(trieNode_t **root);
void trieAdd(trieNode_t **root, char *key, double longt, double latt);
trieNode_t* TrieSearch(trieNode_t *root, const char *key);
trieNode_t * createTrieNode(char key, char *entry_name, double longt, double latt);
void TrieAddEntry(trieNode_t **root, char *key, char *entry_name, double longt, double latt);

void createNode(trieNode_t **root){

  *root = createTrieNode('\0',"\0", 0xffffffff,0xffffffff);
}

trieNode_t * createTrieNode(char key, char *entry_name, double longt, double latt)
{
  trieNode_t *node = (trieNode_t *)malloc(sizeof(trieNode_t));

  node->next = NULL;
  node->key = key;
  node->entry = strdup(entry_name);
  node->longitude = longt;
  node->latitude = latt;
  node->previous = NULL;
  node->parent = NULL;
  node->children = NULL;

  return node;
}

void trieAdd(trieNode_t **root, char *key, double longt, double latt)
{
  TrieAddEntry(root, key, key, longt, latt);
}

void TrieAddEntry(trieNode_t **root, char *key, char *entry_name, double lon, double lat)
{
  trieNode_t *pTrav = NULL;

  if(NULL == *root)
	{
	  //printf("NULL tree\n");
	  return;
	}

  //printf("\nInserting key %s: \n",key);

  pTrav = (*root)->children;

  if(pTrav == NULL)
	{
	  /*First Node*/
	  for(pTrav = *root; *key; pTrav = pTrav->children)
		{
		  pTrav->children = createTrieNode(*key, "\0", 0xffffffff, 0xffffffff);
		  pTrav->children->parent = pTrav;
		  //printf("Inserting: [%c]\n",pTrav->children->key);

		  key++;
		}

	  pTrav->children = createTrieNode('\0', entry_name, lon, lat);
	  pTrav->children->parent = pTrav;

	  //printf("Inserting: [%c]\n",pTrav->children->key);

	  return;
	}

  if(TrieSearch(pTrav, key))
	{
	  //printf("Duplicate!\n");
	  //return;
	}

  while(*key != '\0')
	{
	  if(*key == pTrav->key)
		{
		  key++;

		  //printf("Traversing child: [%c]\n",pTrav->children->key);

		  pTrav = pTrav->children;
		}
	  else
		break;
	}

  while(pTrav->next)
	{
	  if(*key == pTrav->next->key)
		{
		  key++;
		  TrieAddEntry(&(pTrav->next), key, entry_name, lon, lat);
		  return;
		}
	  pTrav = pTrav->next;
	}

  if(*key)
	{
	  pTrav->next = createTrieNode(*key, "\0", 0xffffffff, 0xffffffff);
	}
  else
	{
	  pTrav->next = createTrieNode(*key, entry_name, lon, lat);
	}

  pTrav->next->parent = pTrav->parent;
  pTrav->next->previous = pTrav;


  //printf("Inserting [%c] as neighbour of [%c] \n",pTrav->next->key, pTrav->key);


  if(!(*key))
	return;

  key++;

  for(pTrav = pTrav->next; *key; pTrav = pTrav->children)
	{
	  pTrav->children = createTrieNode(*key, "\0", 0xffffffff, 0xffffffff);
	  pTrav->children->parent = pTrav;

	  //printf("Inserting: [%c]\n",pTrav->children->key);

	  key++;
	}

  pTrav->children = createTrieNode('\0', entry_name, lon, lat);
  pTrav->children->parent = pTrav;

  //printf("Inserting: [%c]\n",pTrav->children->key);

}

trieNode_t* TrieSearch(trieNode_t *root, const char *key)
{
  trieNode_t *level = root;
  trieNode_t *pPtr = NULL;

  while(1)
	{
	  trieNode_t *found = NULL;
	  trieNode_t *curr;

	  for (curr = level; curr != NULL; curr = curr->next)
		{
		  // printf("Comparing: [%c] with [%c]\n",curr->key, *key);

		  if (curr->key == *key)
			{
			  //  printf("Found!\n");
			  found = curr;

			  break;}
		}
	  if (found == NULL)
		return NULL;

	  if (*key == '\0')
		{
		  pPtr = curr;
		  return pPtr;
		}

	  level = found->children;
	  key++;
	}
}


trieNode_t *partialSearch(trieNode_t *root, const char *key){
  trieNode_t *level = root;
  trieNode_t *pPtr = NULL;
  while(1)
	{
	  trieNode_t *found = NULL;
	  trieNode_t *curr;

	  for (curr = level; curr != NULL; curr = curr->next)
		{

		  //printf("Comparing: [%c] with [%c]\n",curr->key, *key);
		  if (curr->key == *key)
			{
			  // printf("Found!\n");
			  found = curr;
			  //printf("%s", curr->entry);
			  break; }
		  /* else if will continue to travel down the trie in the case that a partial match with a trie entry is found */
		  else if (*key == '\0')
			{
			  //printf("Moving along\n");
			  found = curr;
			  key--;
			  break;}
		}
	  //printf("%s", curr->entry);
	  if (found == NULL)
		return NULL;

	  if (*key == '\0')
		{
		  pPtr = curr;
		  return pPtr;
		}

	  level = found->children;
	  key++;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                           TRIE DATA STRUCTURE ENDS                                                //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

trieNode_t *root;

struct place {
  char name[255];
  char state[2];
  float latitude;
  float longitude;
};

typedef struct place Place;

char *trimSpaces(char *str)
{
  char *endl;

  while(isspace(*str))
	str++;

  endl = str + strlen(str) - 1;
  while(endl > str && isspace(*endl)) endl--;

  *(endl+1) = 0;

  return str;
}

Place *  parseLine(char * line){

  Place *p = malloc(sizeof *p);
  char * temp = malloc(sizeof *temp);

  strncpy(p->name, line+9, 64); // name
  strncpy(p->name, trimSpaces(p->name), strlen(p->name)); // trimming spaces

  strncpy(p->state, line, 2);   // state

  strncpy(temp, line+143, 10);
  p->latitude = atof(temp);     // latitude

  strncpy(temp, line+153, 11);  // longitude
  p->longitude = atof(temp);

  return p;
};

void verymain(){
  createNode(&root);
  FILE *placesFile;
  char line[255];

  printf("\n BEFORE READING FILE \n");
  placesFile = fopen("places2k.txt", "r");
  printf("\n after FOPEN \n");

  if(placesFile != NULL){

	while(fgets(line, sizeof(line), placesFile) != NULL){

	  char key[255];
	  Place *p = parseLine(line);
	  // printf("debug1");

	  strcpy(key,p->state);
	  strcat(key,p->name);

	  int i;
	  for(i=0; key[i]; i++)
		key[i] = tolower(key[i]);

	  trieAdd(&root, key, p->longitude, p->latitude);
	  free(p);
	  //  printf("debug2");
	}
	fclose(placesFile);
  }

}

places_list *
places_1_svc(struct location *argp, struct svc_req *rqstp)
{

  static places_list result;
  trieNode_t *searchNode = (struct trieNode *) malloc(sizeof(struct trieNode));
  placeslist head = NULL;
  placeslist *list;
  placeslist temp;
  char actual_city[255];
  char actual_state[2];
  char searchstr[255];
	
  
  strcpy(searchstr, argp->state);
  //searchstr[2]='\0';
  printf("server state %s", argp->state);
  strcat(searchstr, argp->city);
  printf("server city %s", argp->city);
  int i;
  for(i=0; searchstr[i]; i++)
	{
	  searchstr[i] = tolower(searchstr[i]);
	}

  searchNode = partialSearch(root->children, searchstr);

  xdr_free((xdrproc_t)xdr_places_list, (char *)&result);
  
  CLIENT *clnt;
  airport_list  *result_1;
  struct position  airports_1_arg;
  char *host = argp->host;

  clnt = clnt_create (host, AIRPORTPROG, AIRPORTVERS, "udp");
  if (clnt == NULL) {
	clnt_pcreateerror (host);
	exit (1);
  }

  if(searchNode){
	
  }else{
	result.errno=1;
	return &result;
  }
  airports_1_arg.latitude=searchNode->latitude;
  airports_1_arg.longitude =searchNode->longitude;

  
  result_1 = airports_1(&airports_1_arg, clnt);
  if (result_1 == (airport_list *) NULL) {
	clnt_perror (clnt, "call failed");
	exit(1);
  }
  if(result_1->errno>0){
	clnt_freeres(clnt, (xdrproc_t)xdr_airport_list, (char *)result_1);
	result.errno=2;
	return &result;
  }
  airportlist l=result_1->airport_list_u.list;
  placeslist* nlp = &result.places_list_u.list;
  placeslist p;
  //char *lat;
  /*
  p = (placestruct *)malloc(sizeof(struct placestruct));

  actual_state[0]=searchNode->entry[0];
  actual_state[1]=searchNode->entry[1];
  for(i=2; i<strlen(searchNode->entry); i++){
	actual_city[i-2]=searchNode->entry[i];
  }

  p->code = strdup(actual_state);
  p->place=strdup(actual_city);
  p->state=strdup(actual_state);
  p->longitude=searchNode->longitude;
  p->latitude=searchNode->latitude;
  p->distance=0;
  p->next=NULL;
  *nlp=p;
  nlp=&p->next;
  memset(actual_city, 0, 255);
  */
  while(l){
	
	
	for(i=0; i<strlen(l->name)-3; i++){
	  actual_city[i]=l->name[i];
	}
	actual_state[0]=l->name[i+1];
	actual_state[1]=l->name[i+2];
	
	
	p = (placestruct *)malloc(sizeof(struct placestruct));
	p->code=strdup(l->code);
	p->place=strdup(actual_city);
    p->state=strdup(actual_state);
	p->distance=l->distance;
	p->next=NULL;
	*nlp=p;
	nlp=&p->next;
	l=l->next;
	memset(actual_city, 0, 255);
  }
  
  xdr_free((xdrproc_t)xdr_airport_list, (char *)result_1);

  clnt_destroy (clnt);
  
  result.errno=0;
  return(&result);
}
